Ideas
- Boost
	- Player has a boost meter.
	- Player can use boost to hit other players.
	- Player can hit/collect things to get more boost.
	- When a player collects boost, players in higher positions get less.
- Player can hit/collect a certain amount of things to unlock a shortcut only they can use.
- Status affects
	- Fire: top speed and acceleration are lowered.
	- Shock: steering disabled.
	- Ice: car essentially becomes a block of ice. Steering and engine are disabled, friction is greatly reduced.
- Cube which can withstand a couple hits then explode into fire and shock status effects. The ground is covered with the status effect where the cube exploded and it remains for the rest of the level. (Intead of cubes, do I want to use barrels?)
	- Could have cubes which do not explode and barrels which do.
- Status effect entities
	- Shock
		- Non exploding rigid body cubes - touch it and your car loses steering
		- Exploding rigid body barrels - leave behind a cloud of shockiness
	- Fire
		- Non exploding rigid body cubes - touch it and your car lights on fire
		- Exploding rigid body barrels full of oil - leaves behind an oil slick on fire 
			- This would be hard to do technically, perhaps we could settle for archored barrels which are not rigid body enabled
	- Ice
		- Non exploding rigid body cubes - touch it and your car turns into an ice block
		- Exploding rigid body barrels full of dry ice - leaves behind a cloud of dry ice
- Side/cylinder bumpers which fire off when the player gets close.
- Giant fans which can blow your car sideways or up.
- Hitting a normal rigid body slows down the player.
- Surface types: friction is changed.
	- Concrete/asphalt, mud, ice, oil slicks.
- Boost pad/jet
	- Gives a bigger boost than using boost meter would give.
	- All rigid bodies can be accelerated by this.
- Oil drum that breaks into an oil slick.
- Short cut which opens up once the player has collected a key.
- Moving conveyor belts that can carry things

A note about the car wheel positioning. When the car is in the air such that the suspension is not colliding with the ground, we max out the spring length to the same value as the maximum spring ray length. For the position of the wheel,
we could pick a different maximum length. It's intentionally designed such that the ray length is pretty long to provide better stability so we'll probably want to use a different max length for the visual position of the wheel.

Improvements
- Instead of exporting multiple ground collision meshes, then loading in and inserting each one into the ground grid. Why don't we have the exporter do the work of combining the collision meshes into one big array of indices and positions.

Todo
- Cylinder bumper
	- Cylinder collision detection and resolution
		- [done] Create a basic scene with a cylinder rigid body
		- [done] Export it
		- [done] Import it
		- [done] Cylinder hull visualizer
		- Contacts visualizer
		- Consider changing the EPA tolerances, it could be taking a lot of iterations for not much gain.
		- [done] Ensure sure .Keep and .KeepRender are working
		- [done] Cylinder vs other hull collisions
		- Something to consider. When calculating the bounds for cylinders, we could just directly calculate the AABB. You would calculate it as if the local bounds were rotated 45 degrees since that is the worst case scenaro.
		- Try to remove the nesting in the collision procs
		- Manifold reduction
		- Spring vs cylinder collisions
	- Blender design (should be consistent with rail bumper)
	- Exporting
	- Importing
	- Gameplay logic
- File for settings
- Slow the car down when you hit a rigid body
- Boost jets
- The case where a geometry is marked as Free has a problem I believe. You see the free-ing logic only happens once you remove an entity from a geometry. So, if you create a geometry, mark it as Free and never assign an entity to it. I think the geometry really should be cleaned up but that'll never happen. Maybe we should add some debug logic that runs every frame to catch this potential memory leak.

Sequential impulse solver
	- I'm questioning if the impulse clamping is correct. When the object has a large overshoot (due to a small delta time) we're seeing iterations which could be spent correcting
	the impulse but they don't do anything. Maybe this is correct behavior and I need to put a lower bound on delta time, maybe the clamping logic is incorrect, need to investigate.
		- Need to check this again given the fix we made for the other issue
	- Since we're getting objects flying up into the air if they have big penetrations, can I just set the velocity to 0 in the direction of the collision normal once the solver has finished its work?

For a cool particle explosion effect do this:
	RANGE :: 5;

	particle.velocity.x += rand.float32_range(-RANGE, RANGE);
	particle.velocity.y += rand.float32_range(-RANGE, RANGE);
	particle.velocity.z += rand.float32_range(-RANGE, RANGE);
	particle.position += particle.velocity * dt;