Git commands
- Remove last commit but keep changes: `git reset HEAD~1`
- Checkout to remote branch: `git fetch` then `git switch <branch>`

Ideas
- Boost
	- Player has a boost meter.
	- Player can use boost to hit other players.
	- Player can hit/collect things to get more boost.
	- When a player collects boost, players in higher positions get less.
- Player can hit/collect a certain amount of things to unlock a shortcut only they can use.
- Status affects
	- Fire: top speed and acceleration are lowered.
	- Shock: steering disabled.
	- Ice: car essentially becomes a block of ice. Steering and engine are disabled, friction is greatly reduced.
- Cube which can withstand a couple hits then explode into fire and shock status effects. The ground is covered with the status effect where the cube exploded and it remains for the rest of the level. (Intead of cubes, do I want to use barrels?)
	- Could have cubes which do not explode and barrels which do.
- Status effect entities
	- Shock
		- Non exploding rigid body cubes - touch it and your car loses steering
		- Exploding rigid body barrels - leave behind a cloud of shockiness
	- Fire
		- Non exploding rigid body cubes - touch it and your car lights on fire
		- Exploding rigid body barrels full of oil - leaves behind an oil slick on fire 
			- This would be hard to do technically, perhaps we could settle for archored barrels which are not rigid body enabled
	- Ice
		- Non exploding rigid body cubes - touch it and your car turns into an ice block
		- Exploding rigid body barrels full of dry ice - leaves behind a cloud of dry ice
	- I think any rigid body should be able to be shocked/caught on fire/frozen. The status effect only needs to happen for a second or two. It would just add another layer of cool sandboxyness.
- Side/cylinder bumpers which fire off when the player gets close.
- Giant fans which can blow your car sideways or up.
- Hitting a normal rigid body slows down the player.
- Surface types: friction is changed.
	- Concrete/asphalt, mud, ice, oil slicks.
- Boost pad/jet
	- Gives a bigger boost than using boost meter would give.
	- All rigid bodies can be accelerated by this.
- Oil drum that breaks into an oil slick.
- Short cut which opens up once the player has collected a key.
- Moving conveyor belts that can carry things

A note about the car wheel positioning. When the car is in the air such that the suspension is not colliding with the ground, we max out the spring length to the same value as the maximum spring ray length. For the position of the wheel,
we could pick a different maximum length. It's intentionally designed such that the ray length is pretty long to provide better stability so we'll probably want to use a different max length for the visual position of the wheel.

Improvements
- Instead of exporting multiple ground collision meshes, then loading in and inserting each one into the ground grid. Why don't we have the exporter do the work of combining the collision meshes into one big array of indices and positions.
- Cylinder top and bottom faces can generate more than four contacts. This means we could implement manifold reduction. I did some investigation and it looks like it's not generating more than 5 contacts even though it could theoretically generate 8.

Todo
- Exploding shock barrels
	- Explosion particle effect
	- Rigid bodies should be affected by the cloud
	- Consider having little rigid bodies ignored from more things like the car suspension
	- I think the thin rectangular shrapnel piece is too thin, seems like it's falling through the ground plane from high up. Should increase that hull size if that is happening.
- Exploding fire barrels
	- Oil slicks
		- Mesh model
		- Triangle hull
		- Exporting
		- Importing
		- Gameplay logic - less friction
			- How this work? When we have a ground constraint, form a little line segment at the constraint position in the direction of the surface normal. Then it's simply a ray-v-triangle check to know if that contact point is on an oil slick.
		- Why even default entity positions, orentations, sizes? Just require it to be passed in. When do even want to not supply that information?
	- Barrel
		- Mesh model
		- Exporting
		- Importing
		- Gameplay logic
	- Explosion
		- Oil blobs spawn on track using raycasting.
- Cylinder bumper
	- Figure out how to do it. Use restitution? Should it even run through the constraint system?
	- [done] Cylinder collision detection and resolution
	- Blender design (should be consistent with rail bumper)
	- Exporting
	- Importing
	- Gameplay logic
- Slow the car down when you hit a rigid body
- Boost jets
- The case where a geometry is marked as Free has a problem I believe. You see the free-ing logic only happens once you remove an entity from a geometry. So, if you create a geometry, mark it as Free and never assign an entity to it. I think the geometry really should be cleaned up but that'll never happen. Maybe we should add some debug logic that runs every frame to catch this potential memory leak. This is actually not currently an issue. There is an assert that will catch this in the rendering logic. Unless we have a good reason to add some cleanup logic, I say we view this assert as a feature because you shouldn't be adding a geometry and not assigning any entities to it. You can do that but it should be marked correctly i.e. on_no_entities = Keep or KeepRender.
- Move the window stuff into a window file

Good things to do on laptop
- Improve car wheel helpers
	- Render them up to date
	- Make config setting
- Clean up the -vet things
- Export and import names - This would've saved me some time in debugging an issue. Specifically, attaching the Blender geometry name to the Geometry struct would've been nice.
- Wireframe triangle geometry for mesh hull helpers.
- Hull bounds helpers - this is different than the hull helpers, it would show you the axis aligned bounding boxes of the hulls.
- Shader hot reloading?

Sequential impulse solver
	- I'm questioning if the impulse clamping is correct. When the object has a large overshoot (due to a small delta time) we're seeing iterations which could be spent correcting
	the impulse but they don't do anything. Maybe this is correct behavior and I need to put a lower bound on delta time, maybe the clamping logic is incorrect, need to investigate.
		- Need to check this again given the fix we made for the other issue
	- Since we're getting objects flying up into the air if they have big penetrations, can I just set the velocity to 0 in the direction of the collision normal once the solver has finished its work? We tried this, it didn't really work out. Objects fell weird and friction had to be done a different way where they're not constraints. Angular and linear velocity damping was used. Maybe there is still some usefulness of this approach only when impulses are very large to prevent them from flying all crazy.

For a cool particle explosion effect do this:
	RANGE :: 5;

	particle.velocity.x += rand.float32_range(-RANGE, RANGE);
	particle.velocity.y += rand.float32_range(-RANGE, RANGE);
	particle.velocity.z += rand.float32_range(-RANGE, RANGE);
	particle.position += particle.velocity * dt;